{"ast":null,"code":"\"use strict\";\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spread = this && this.__spread || function () {\n  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n\n  return ar;\n};\n\nvar __values = this && this.__values || function (o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n      i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar lru_cache_1 = __importDefault(require(\"lru-cache\"));\n\nvar events_1 = require(\"events\");\n\nvar lodash_clonedeep_1 = __importDefault(require(\"lodash.clonedeep\"));\n\nvar freeze_1 = require(\"./freeze\");\n\nvar sync_1 = require(\"./sync\");\n\nfunction asyncMemoizer(options) {\n  var cache = new lru_cache_1.default(options);\n  var load = options.load;\n  var hash = options.hash;\n  var bypass = options.bypass;\n  var itemMaxAge = options.itemMaxAge;\n  var freeze = options.freeze;\n  var clone = options.clone;\n  var queueMaxAge = options.queueMaxAge || 1000;\n  var loading = new Map();\n  var emitter = new events_1.EventEmitter();\n  var memoizerMethods = Object.assign({\n    del: del,\n    reset: function () {\n      return cache.reset();\n    },\n    keys: cache.keys.bind(cache),\n    on: emitter.on.bind(emitter),\n    once: emitter.once.bind(emitter)\n  }, options);\n\n  if (options.disable) {\n    return Object.assign(load, memoizerMethods);\n  }\n\n  function del() {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    var key = hash.apply(void 0, __spread(args));\n    cache.del(key);\n  }\n\n  function add(key, parameters, result) {\n    if (freeze) {\n      result.forEach(freeze_1.deepFreeze);\n    }\n\n    if (itemMaxAge) {\n      cache.set(key, result, itemMaxAge.apply(void 0, __spread(parameters.concat(result))));\n    } else {\n      cache.set(key, result);\n    }\n  }\n\n  function runCallbacks(callbacks, args) {\n    var e_1, _a;\n\n    try {\n      for (var callbacks_1 = __values(callbacks), callbacks_1_1 = callbacks_1.next(); !callbacks_1_1.done; callbacks_1_1 = callbacks_1.next()) {\n        var callback = callbacks_1_1.value; // Simulate async call when returning from cache\n        // and yield between callback resolution\n\n        if (clone) {\n          setImmediate.apply(void 0, __spread([callback], args.map(lodash_clonedeep_1.default)));\n        } else {\n          setImmediate.apply(void 0, __spread([callback], args));\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (callbacks_1_1 && !callbacks_1_1.done && (_a = callbacks_1.return)) _a.call(callbacks_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  }\n\n  function emit(event) {\n    var parameters = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      parameters[_i - 1] = arguments[_i];\n    }\n\n    emitter.emit.apply(emitter, __spread([event], parameters));\n  }\n\n  function memoizedFunction() {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    var parameters = args.slice(0, -1);\n    var callback = args.slice(-1).pop();\n    var key;\n\n    if (bypass && bypass.apply(void 0, __spread(parameters))) {\n      emit.apply(void 0, __spread(['miss'], parameters));\n      return load.apply(void 0, __spread(args));\n    }\n\n    if (parameters.length === 0 && !hash) {\n      //the load function only receives callback.\n      key = '_';\n    } else {\n      key = hash.apply(void 0, __spread(parameters));\n    }\n\n    var fromCache = cache.get(key);\n\n    if (fromCache) {\n      emit.apply(void 0, __spread(['hit'], parameters)); // found, invoke callback\n\n      return runCallbacks([callback], [null].concat(fromCache));\n    }\n\n    var pendingLoad = loading.get(key);\n\n    if (pendingLoad && pendingLoad.expiresAt > Date.now()) {\n      // request already in progress, queue and return\n      pendingLoad.queue.push(callback);\n      emit.apply(void 0, __spread(['queue'], parameters));\n      return;\n    }\n\n    emit.apply(void 0, __spread(['miss'], parameters));\n    var started = Date.now(); // no pending request or not resolved before expiration\n    // create a new queue and invoke load\n\n    var queue = [callback];\n    loading.set(key, {\n      queue: queue,\n      expiresAt: started + queueMaxAge\n    });\n\n    var loadHandler = function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      var err = args[0];\n\n      if (!err) {\n        add(key, parameters, args.slice(1));\n      } // this can potentially delete a different queue than `queue` if\n      // this callback was called after expiration.\n      // that will only cause a new call to be performed and a new queue to be\n      // created\n\n\n      loading.delete(key);\n      emit.apply(void 0, __spread(['loaded', Date.now() - started], parameters));\n      runCallbacks(queue, args);\n    };\n\n    load.apply(void 0, __spread(parameters, [loadHandler]));\n  }\n\n  ;\n  return Object.assign(memoizedFunction, memoizerMethods);\n}\n\nexports.asyncMemoizer = asyncMemoizer;\nasyncMemoizer.sync = sync_1.syncMemoizer;","map":{"version":3,"mappings":"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","names":["asyncMemoizer","options","cache","lru_cache_1","load","hash","bypass","itemMaxAge","freeze","clone","queueMaxAge","loading","Map","emitter","events_1","memoizerMethods","Object","assign","del","reset","keys","bind","on","once","disable","args","key","__spread","add","parameters","result","forEach","freeze_1","set","concat","runCallbacks","callbacks","callbacks_1_1","callback","setImmediate","map","lodash_clonedeep_1","emit","event","apply","memoizedFunction","slice","pop","length","fromCache","get","pendingLoad","expiresAt","Date","now","queue","push","started","loadHandler","err","delete","exports","sync","sync_1"],"sourceRoot":"","sources":["../src/async.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}