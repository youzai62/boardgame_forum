{"ast":null,"code":"const isObject = require('../help/is_object');\n\nconst epoch = require('../help/epoch');\n\nconst secs = require('../help/secs');\n\nconst getKey = require('../help/get_key');\n\nconst {\n  bare: verify\n} = require('../jws/verify');\n\nconst {\n  JWTClaimInvalid,\n  JWTExpired\n} = require('../errors');\n\nconst {\n  isString,\n  isNotString,\n  isNotArrayOfStrings,\n  isTimestamp,\n  isStringOrArrayOfStrings\n} = require('./shared_validations');\n\nconst decode = require('./decode');\n\nconst isPayloadString = isString.bind(undefined, JWTClaimInvalid);\nconst isOptionString = isString.bind(undefined, TypeError);\n\nconst normalizeTyp = value => value.toLowerCase().replace(/^application\\//, '');\n\nconst validateOptions = _ref => {\n  let {\n    algorithms,\n    audience,\n    clockTolerance,\n    complete = false,\n    crit,\n    ignoreExp = false,\n    ignoreIat = false,\n    ignoreNbf = false,\n    issuer,\n    jti,\n    maxTokenAge,\n    now = new Date(),\n    subject,\n    typ\n  } = _ref;\n\n  if (typeof complete !== 'boolean') {\n    throw new TypeError('options.complete must be a boolean');\n  }\n\n  if (typeof ignoreExp !== 'boolean') {\n    throw new TypeError('options.ignoreExp must be a boolean');\n  }\n\n  if (typeof ignoreNbf !== 'boolean') {\n    throw new TypeError('options.ignoreNbf must be a boolean');\n  }\n\n  if (typeof ignoreIat !== 'boolean') {\n    throw new TypeError('options.ignoreIat must be a boolean');\n  }\n\n  isOptionString(maxTokenAge, 'options.maxTokenAge');\n  isOptionString(subject, 'options.subject');\n  isOptionString(jti, 'options.jti');\n  isOptionString(clockTolerance, 'options.clockTolerance');\n  isOptionString(typ, 'options.typ');\n\n  if (issuer !== undefined && isNotString(issuer) && isNotArrayOfStrings(issuer)) {\n    throw new TypeError('options.issuer must be a string or an array of strings');\n  }\n\n  if (audience !== undefined && isNotString(audience) && isNotArrayOfStrings(audience)) {\n    throw new TypeError('options.audience must be a string or an array of strings');\n  }\n\n  if (algorithms !== undefined && isNotArrayOfStrings(algorithms)) {\n    throw new TypeError('options.algorithms must be an array of strings');\n  }\n\n  if (!(now instanceof Date) || !now.getTime()) {\n    throw new TypeError('options.now must be a valid Date object');\n  }\n\n  if (ignoreIat && maxTokenAge !== undefined) {\n    throw new TypeError('options.ignoreIat and options.maxTokenAge cannot used together');\n  }\n\n  if (crit !== undefined && isNotArrayOfStrings(crit)) {\n    throw new TypeError('options.crit must be an array of strings');\n  }\n\n  return {\n    algorithms,\n    audience,\n    clockTolerance,\n    complete,\n    crit,\n    ignoreExp,\n    ignoreIat,\n    ignoreNbf,\n    issuer,\n    jti,\n    maxTokenAge,\n    now,\n    subject,\n    typ\n  };\n};\n\nconst validateTypes = (_ref2, options) => {\n  let {\n    header,\n    payload\n  } = _ref2;\n  isPayloadString(header.alg, '\"alg\" header parameter', 'alg', true);\n  isTimestamp(payload.iat, 'iat', !!options.maxTokenAge);\n  isTimestamp(payload.exp, 'exp');\n  isTimestamp(payload.nbf, 'nbf');\n  isPayloadString(payload.jti, '\"jti\" claim', 'jti', !!options.jti);\n  isStringOrArrayOfStrings(payload.iss, 'iss', !!options.issuer);\n  isPayloadString(payload.sub, '\"sub\" claim', 'sub', !!options.subject);\n  isStringOrArrayOfStrings(payload.aud, 'aud', !!options.audience);\n  isPayloadString(header.typ, '\"typ\" header parameter', 'typ', !!options.typ);\n};\n\nconst checkAudiencePresence = (audPayload, audOption) => {\n  if (typeof audPayload === 'string') {\n    return audOption.includes(audPayload);\n  } // Each principal intended to process the JWT MUST\n  // identify itself with a value in the audience claim\n\n\n  audPayload = new Set(audPayload);\n  return audOption.some(Set.prototype.has.bind(audPayload));\n};\n\nmodule.exports = function (token, key) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (!isObject(options)) {\n    throw new TypeError('options must be an object');\n  }\n\n  const {\n    algorithms,\n    audience,\n    clockTolerance,\n    complete,\n    crit,\n    ignoreExp,\n    ignoreIat,\n    ignoreNbf,\n    issuer,\n    jti,\n    maxTokenAge,\n    now,\n    subject,\n    typ\n  } = options = validateOptions(options);\n  const decoded = decode(token, {\n    complete: true\n  });\n  key = getKey(key, true);\n\n  if (complete) {\n    ({\n      key\n    } = verify(true, 'preparsed', {\n      decoded,\n      token\n    }, key, {\n      crit,\n      algorithms,\n      complete: true\n    }));\n    decoded.key = key;\n  } else {\n    verify(true, 'preparsed', {\n      decoded,\n      token\n    }, key, {\n      crit,\n      algorithms\n    });\n  }\n\n  const unix = epoch(now);\n  validateTypes(decoded, options);\n\n  if (issuer && (typeof decoded.payload.iss !== 'string' || !(typeof issuer === 'string' ? [issuer] : issuer).includes(decoded.payload.iss))) {\n    throw new JWTClaimInvalid('unexpected \"iss\" claim value', 'iss', 'check_failed');\n  }\n\n  if (subject && decoded.payload.sub !== subject) {\n    throw new JWTClaimInvalid('unexpected \"sub\" claim value', 'sub', 'check_failed');\n  }\n\n  if (jti && decoded.payload.jti !== jti) {\n    throw new JWTClaimInvalid('unexpected \"jti\" claim value', 'jti', 'check_failed');\n  }\n\n  if (audience && !checkAudiencePresence(decoded.payload.aud, typeof audience === 'string' ? [audience] : audience)) {\n    throw new JWTClaimInvalid('unexpected \"aud\" claim value', 'aud', 'check_failed');\n  }\n\n  if (typ && normalizeTyp(decoded.header.typ) !== normalizeTyp(typ)) {\n    throw new JWTClaimInvalid('unexpected \"typ\" JWT header value', 'typ', 'check_failed');\n  }\n\n  const tolerance = clockTolerance ? secs(clockTolerance) : 0;\n\n  if (!ignoreIat && !('exp' in decoded.payload) && 'iat' in decoded.payload && decoded.payload.iat > unix + tolerance) {\n    throw new JWTClaimInvalid('\"iat\" claim timestamp check failed (it should be in the past)', 'iat', 'check_failed');\n  }\n\n  if (!ignoreNbf && 'nbf' in decoded.payload && decoded.payload.nbf > unix + tolerance) {\n    throw new JWTClaimInvalid('\"nbf\" claim timestamp check failed', 'nbf', 'check_failed');\n  }\n\n  if (!ignoreExp && 'exp' in decoded.payload && decoded.payload.exp <= unix - tolerance) {\n    throw new JWTExpired('\"exp\" claim timestamp check failed', 'exp', 'check_failed');\n  }\n\n  if (maxTokenAge) {\n    const age = unix - decoded.payload.iat;\n    const max = secs(maxTokenAge);\n\n    if (age - tolerance > max) {\n      throw new JWTExpired('\"iat\" claim timestamp check failed (too far in the past)', 'iat', 'check_failed');\n    }\n\n    if (age < 0 - tolerance) {\n      throw new JWTClaimInvalid('\"iat\" claim timestamp check failed (it should be in the past)', 'iat', 'check_failed');\n    }\n  }\n\n  return complete ? decoded : decoded.payload;\n};","map":{"version":3,"sources":["C:/Users/zhuji/Desktop/heroku_sample/starter/Frontend/node_modules/jose/lib/jwt/verify.js"],"names":["isObject","require","epoch","secs","getKey","bare","verify","JWTClaimInvalid","JWTExpired","isString","isNotString","isNotArrayOfStrings","isTimestamp","isStringOrArrayOfStrings","decode","isPayloadString","bind","undefined","isOptionString","TypeError","normalizeTyp","value","toLowerCase","replace","validateOptions","algorithms","audience","clockTolerance","complete","crit","ignoreExp","ignoreIat","ignoreNbf","issuer","jti","maxTokenAge","now","Date","subject","typ","getTime","validateTypes","options","header","payload","alg","iat","exp","nbf","iss","sub","aud","checkAudiencePresence","audPayload","audOption","includes","Set","some","prototype","has","module","exports","token","key","decoded","unix","tolerance","age","max"],"mappings":"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","sourcesContent":["const isObject = require('../help/is_object')\nconst epoch = require('../help/epoch')\nconst secs = require('../help/secs')\nconst getKey = require('../help/get_key')\nconst { bare: verify } = require('../jws/verify')\nconst { JWTClaimInvalid, JWTExpired } = require('../errors')\n\nconst {\n  isString,\n  isNotString,\n  isNotArrayOfStrings,\n  isTimestamp,\n  isStringOrArrayOfStrings\n} = require('./shared_validations')\nconst decode = require('./decode')\n\nconst isPayloadString = isString.bind(undefined, JWTClaimInvalid)\nconst isOptionString = isString.bind(undefined, TypeError)\n\nconst normalizeTyp = (value) => value.toLowerCase().replace(/^application\\//, '')\n\nconst validateOptions = ({\n  algorithms, audience, clockTolerance, complete = false, crit, ignoreExp = false,\n  ignoreIat = false, ignoreNbf = false, issuer, jti, maxTokenAge, now = new Date(),\n  subject, typ\n}) => {\n  if (typeof complete !== 'boolean') {\n    throw new TypeError('options.complete must be a boolean')\n  }\n\n  if (typeof ignoreExp !== 'boolean') {\n    throw new TypeError('options.ignoreExp must be a boolean')\n  }\n\n  if (typeof ignoreNbf !== 'boolean') {\n    throw new TypeError('options.ignoreNbf must be a boolean')\n  }\n\n  if (typeof ignoreIat !== 'boolean') {\n    throw new TypeError('options.ignoreIat must be a boolean')\n  }\n\n  isOptionString(maxTokenAge, 'options.maxTokenAge')\n  isOptionString(subject, 'options.subject')\n  isOptionString(jti, 'options.jti')\n  isOptionString(clockTolerance, 'options.clockTolerance')\n  isOptionString(typ, 'options.typ')\n\n  if (issuer !== undefined && (isNotString(issuer) && isNotArrayOfStrings(issuer))) {\n    throw new TypeError('options.issuer must be a string or an array of strings')\n  }\n\n  if (audience !== undefined && (isNotString(audience) && isNotArrayOfStrings(audience))) {\n    throw new TypeError('options.audience must be a string or an array of strings')\n  }\n\n  if (algorithms !== undefined && isNotArrayOfStrings(algorithms)) {\n    throw new TypeError('options.algorithms must be an array of strings')\n  }\n\n  if (!(now instanceof Date) || !now.getTime()) {\n    throw new TypeError('options.now must be a valid Date object')\n  }\n\n  if (ignoreIat && maxTokenAge !== undefined) {\n    throw new TypeError('options.ignoreIat and options.maxTokenAge cannot used together')\n  }\n\n  if (crit !== undefined && isNotArrayOfStrings(crit)) {\n    throw new TypeError('options.crit must be an array of strings')\n  }\n\n  return {\n    algorithms,\n    audience,\n    clockTolerance,\n    complete,\n    crit,\n    ignoreExp,\n    ignoreIat,\n    ignoreNbf,\n    issuer,\n    jti,\n    maxTokenAge,\n    now,\n    subject,\n    typ\n  }\n}\n\nconst validateTypes = ({ header, payload }, options) => {\n  isPayloadString(header.alg, '\"alg\" header parameter', 'alg', true)\n\n  isTimestamp(payload.iat, 'iat', !!options.maxTokenAge)\n  isTimestamp(payload.exp, 'exp')\n  isTimestamp(payload.nbf, 'nbf')\n  isPayloadString(payload.jti, '\"jti\" claim', 'jti', !!options.jti)\n  isStringOrArrayOfStrings(payload.iss, 'iss', !!options.issuer)\n  isPayloadString(payload.sub, '\"sub\" claim', 'sub', !!options.subject)\n  isStringOrArrayOfStrings(payload.aud, 'aud', !!options.audience)\n  isPayloadString(header.typ, '\"typ\" header parameter', 'typ', !!options.typ)\n}\n\nconst checkAudiencePresence = (audPayload, audOption) => {\n  if (typeof audPayload === 'string') {\n    return audOption.includes(audPayload)\n  }\n\n  // Each principal intended to process the JWT MUST\n  // identify itself with a value in the audience claim\n  audPayload = new Set(audPayload)\n  return audOption.some(Set.prototype.has.bind(audPayload))\n}\n\nmodule.exports = (token, key, options = {}) => {\n  if (!isObject(options)) {\n    throw new TypeError('options must be an object')\n  }\n\n  const {\n    algorithms, audience, clockTolerance, complete, crit, ignoreExp, ignoreIat, ignoreNbf, issuer,\n    jti, maxTokenAge, now, subject, typ\n  } = options = validateOptions(options)\n\n  const decoded = decode(token, { complete: true })\n  key = getKey(key, true)\n\n  if (complete) {\n    ({ key } = verify(true, 'preparsed', { decoded, token }, key, { crit, algorithms, complete: true }))\n    decoded.key = key\n  } else {\n    verify(true, 'preparsed', { decoded, token }, key, { crit, algorithms })\n  }\n\n  const unix = epoch(now)\n  validateTypes(decoded, options)\n\n  if (issuer && (typeof decoded.payload.iss !== 'string' || !(typeof issuer === 'string' ? [issuer] : issuer).includes(decoded.payload.iss))) {\n    throw new JWTClaimInvalid('unexpected \"iss\" claim value', 'iss', 'check_failed')\n  }\n\n  if (subject && decoded.payload.sub !== subject) {\n    throw new JWTClaimInvalid('unexpected \"sub\" claim value', 'sub', 'check_failed')\n  }\n\n  if (jti && decoded.payload.jti !== jti) {\n    throw new JWTClaimInvalid('unexpected \"jti\" claim value', 'jti', 'check_failed')\n  }\n\n  if (audience && !checkAudiencePresence(decoded.payload.aud, typeof audience === 'string' ? [audience] : audience)) {\n    throw new JWTClaimInvalid('unexpected \"aud\" claim value', 'aud', 'check_failed')\n  }\n\n  if (typ && normalizeTyp(decoded.header.typ) !== normalizeTyp(typ)) {\n    throw new JWTClaimInvalid('unexpected \"typ\" JWT header value', 'typ', 'check_failed')\n  }\n\n  const tolerance = clockTolerance ? secs(clockTolerance) : 0\n\n  if (!ignoreIat && !('exp' in decoded.payload) && 'iat' in decoded.payload && decoded.payload.iat > unix + tolerance) {\n    throw new JWTClaimInvalid('\"iat\" claim timestamp check failed (it should be in the past)', 'iat', 'check_failed')\n  }\n\n  if (!ignoreNbf && 'nbf' in decoded.payload && decoded.payload.nbf > unix + tolerance) {\n    throw new JWTClaimInvalid('\"nbf\" claim timestamp check failed', 'nbf', 'check_failed')\n  }\n\n  if (!ignoreExp && 'exp' in decoded.payload && decoded.payload.exp <= unix - tolerance) {\n    throw new JWTExpired('\"exp\" claim timestamp check failed', 'exp', 'check_failed')\n  }\n\n  if (maxTokenAge) {\n    const age = unix - decoded.payload.iat\n    const max = secs(maxTokenAge)\n\n    if (age - tolerance > max) {\n      throw new JWTExpired('\"iat\" claim timestamp check failed (too far in the past)', 'iat', 'check_failed')\n    }\n\n    if (age < 0 - tolerance) {\n      throw new JWTClaimInvalid('\"iat\" claim timestamp check failed (it should be in the past)', 'iat', 'check_failed')\n    }\n  }\n\n  return complete ? decoded : decoded.payload\n}\n"]},"metadata":{},"sourceType":"script"}