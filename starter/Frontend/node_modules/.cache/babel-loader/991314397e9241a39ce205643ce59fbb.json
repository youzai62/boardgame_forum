{"ast":null,"code":"const {\n  createCipheriv,\n  createDecipheriv,\n  getCiphers\n} = require('crypto');\n\nconst uint64be = require('../help/uint64be');\n\nconst timingSafeEqual = require('../help/timing_safe_equal');\n\nconst {\n  KEYOBJECT\n} = require('../help/consts');\n\nconst {\n  JWEInvalid,\n  JWEDecryptionFailed\n} = require('../errors');\n\nconst checkInput = function (size, iv, tag) {\n  if (iv.length !== 16) {\n    throw new JWEInvalid('invalid iv');\n  }\n\n  if (arguments.length === 3) {\n    if (tag.length !== size / 8) {\n      throw new JWEInvalid('invalid tag');\n    }\n  }\n};\n\nconst encrypt = (size, sign, _ref, cleartext, _ref2) => {\n  let {\n    [KEYOBJECT]: keyObject\n  } = _ref;\n  let {\n    iv,\n    aad = Buffer.alloc(0)\n  } = _ref2;\n  const key = keyObject.export();\n  checkInput(size, iv);\n  const keySize = size / 8;\n  const encKey = key.slice(keySize);\n  const cipher = createCipheriv(`aes-${size}-cbc`, encKey, iv);\n  const ciphertext = Buffer.concat([cipher.update(cleartext), cipher.final()]);\n  const macData = Buffer.concat([aad, iv, ciphertext, uint64be(aad.length * 8)]);\n  const macKey = key.slice(0, keySize);\n  const tag = sign({\n    [KEYOBJECT]: macKey\n  }, macData).slice(0, keySize);\n  return {\n    ciphertext,\n    tag\n  };\n};\n\nconst decrypt = (size, sign, _ref3, ciphertext, _ref4) => {\n  let {\n    [KEYOBJECT]: keyObject\n  } = _ref3;\n  let {\n    iv,\n    tag = Buffer.alloc(0),\n    aad = Buffer.alloc(0)\n  } = _ref4;\n  checkInput(size, iv, tag);\n  const keySize = size / 8;\n  const key = keyObject.export();\n  const encKey = key.slice(keySize);\n  const macKey = key.slice(0, keySize);\n  const macData = Buffer.concat([aad, iv, ciphertext, uint64be(aad.length * 8)]);\n  const expectedTag = sign({\n    [KEYOBJECT]: macKey\n  }, macData, tag).slice(0, keySize);\n  const macCheckPassed = timingSafeEqual(tag, expectedTag);\n\n  if (!macCheckPassed) {\n    throw new JWEDecryptionFailed();\n  }\n\n  let cleartext;\n\n  try {\n    const cipher = createDecipheriv(`aes-${size}-cbc`, encKey, iv);\n    cleartext = Buffer.concat([cipher.update(ciphertext), cipher.final()]);\n  } catch (err) {}\n\n  if (!cleartext) {\n    throw new JWEDecryptionFailed();\n  }\n\n  return cleartext;\n};\n\nmodule.exports = (JWA, JWK) => {\n  ['A128CBC-HS256', 'A192CBC-HS384', 'A256CBC-HS512'].forEach(jwaAlg => {\n    const size = parseInt(jwaAlg.substr(1, 3), 10);\n    const sign = JWA.sign.get(`HS${size * 2}`);\n\n    if (getCiphers().includes(`aes-${size}-cbc`)) {\n      JWA.encrypt.set(jwaAlg, encrypt.bind(undefined, size, sign));\n      JWA.decrypt.set(jwaAlg, decrypt.bind(undefined, size, sign));\n\n      JWK.oct.encrypt[jwaAlg] = JWK.oct.decrypt[jwaAlg] = key => (key.use === 'enc' || key.use === undefined) && key.length / 2 === size;\n    }\n  });\n};","map":{"version":3,"sources":["C:/Users/zhuji/Desktop/heroku_sample/starter/Frontend/node_modules/jose/lib/jwa/aes_cbc_hmac_sha2.js"],"names":["createCipheriv","createDecipheriv","getCiphers","require","uint64be","timingSafeEqual","KEYOBJECT","JWEInvalid","JWEDecryptionFailed","checkInput","size","iv","tag","length","arguments","encrypt","sign","cleartext","keyObject","aad","Buffer","alloc","key","export","keySize","encKey","slice","cipher","ciphertext","concat","update","final","macData","macKey","decrypt","expectedTag","macCheckPassed","err","module","exports","JWA","JWK","forEach","jwaAlg","parseInt","substr","get","includes","set","bind","undefined","oct","use"],"mappings":"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","sourcesContent":["const { createCipheriv, createDecipheriv, getCiphers } = require('crypto')\n\nconst uint64be = require('../help/uint64be')\nconst timingSafeEqual = require('../help/timing_safe_equal')\nconst { KEYOBJECT } = require('../help/consts')\nconst { JWEInvalid, JWEDecryptionFailed } = require('../errors')\n\nconst checkInput = function (size, iv, tag) {\n  if (iv.length !== 16) {\n    throw new JWEInvalid('invalid iv')\n  }\n  if (arguments.length === 3) {\n    if (tag.length !== size / 8) {\n      throw new JWEInvalid('invalid tag')\n    }\n  }\n}\n\nconst encrypt = (size, sign, { [KEYOBJECT]: keyObject }, cleartext, { iv, aad = Buffer.alloc(0) }) => {\n  const key = keyObject.export()\n  checkInput(size, iv)\n\n  const keySize = size / 8\n  const encKey = key.slice(keySize)\n  const cipher = createCipheriv(`aes-${size}-cbc`, encKey, iv)\n  const ciphertext = Buffer.concat([cipher.update(cleartext), cipher.final()])\n  const macData = Buffer.concat([aad, iv, ciphertext, uint64be(aad.length * 8)])\n\n  const macKey = key.slice(0, keySize)\n  const tag = sign({ [KEYOBJECT]: macKey }, macData).slice(0, keySize)\n\n  return { ciphertext, tag }\n}\n\nconst decrypt = (size, sign, { [KEYOBJECT]: keyObject }, ciphertext, { iv, tag = Buffer.alloc(0), aad = Buffer.alloc(0) }) => {\n  checkInput(size, iv, tag)\n\n  const keySize = size / 8\n  const key = keyObject.export()\n  const encKey = key.slice(keySize)\n  const macKey = key.slice(0, keySize)\n\n  const macData = Buffer.concat([aad, iv, ciphertext, uint64be(aad.length * 8)])\n  const expectedTag = sign({ [KEYOBJECT]: macKey }, macData, tag).slice(0, keySize)\n  const macCheckPassed = timingSafeEqual(tag, expectedTag)\n\n  if (!macCheckPassed) {\n    throw new JWEDecryptionFailed()\n  }\n\n  let cleartext\n  try {\n    const cipher = createDecipheriv(`aes-${size}-cbc`, encKey, iv)\n    cleartext = Buffer.concat([cipher.update(ciphertext), cipher.final()])\n  } catch (err) {}\n\n  if (!cleartext) {\n    throw new JWEDecryptionFailed()\n  }\n\n  return cleartext\n}\n\nmodule.exports = (JWA, JWK) => {\n  ['A128CBC-HS256', 'A192CBC-HS384', 'A256CBC-HS512'].forEach((jwaAlg) => {\n    const size = parseInt(jwaAlg.substr(1, 3), 10)\n    const sign = JWA.sign.get(`HS${size * 2}`)\n    if (getCiphers().includes(`aes-${size}-cbc`)) {\n      JWA.encrypt.set(jwaAlg, encrypt.bind(undefined, size, sign))\n      JWA.decrypt.set(jwaAlg, decrypt.bind(undefined, size, sign))\n      JWK.oct.encrypt[jwaAlg] = JWK.oct.decrypt[jwaAlg] = key => (key.use === 'enc' || key.use === undefined) && key.length / 2 === size\n    }\n  })\n}\n"]},"metadata":{},"sourceType":"script"}